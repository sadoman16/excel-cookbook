[
    {
        "name": "VLOOKUP",
        "category": "Lookup & Reference",
        "syntax": "=VLOOKUP(lookup_value, table_array, col_index_num, [range_lookup])",
        "summary": "Looks for a value in the leftmost column of a table and returns a value in the same row from a column you specify.",
        "common_errors": [
            "#N/A (Not Found)",
            "#REF! (Invalid Column Index)",
            "#VALUE! (Wrong Data Type)"
        ],
        "best_practice": "Always use FALSE (0) for exact match unless the data is sorted and you specifically need approximate match.",
        "parameters": [
            {
                "name": "lookup_value",
                "desc": "The value you want to look up."
            },
            {
                "name": "table_array",
                "desc": "The range where the lookup value is located."
            },
            {
                "name": "col_index_num",
                "desc": "The column number in the range that contains the return value."
            },
            {
                "name": "[range_lookup]",
                "desc": "TRUE (1) for approximate match, FALSE (0) for exact match."
            }
        ]
    },
    {
        "name": "IF",
        "category": "Logical",
        "syntax": "=IF(logical_test, value_if_true, [value_if_false])",
        "summary": "Checks whether a condition is met, and returns one value if TRUE, and another value if FALSE.",
        "common_errors": [
            "Nested too deeply (Hard to read)",
            "Missing quotes for text values"
        ],
        "best_practice": "For multiple conditions, consider using IFS (Excel 2019+) instead of nested IFs.",
        "parameters": [
            {
                "name": "logical_test",
                "desc": "The condition you want to test."
            },
            {
                "name": "value_if_true",
                "desc": "The value to return if the condition is TRUE."
            },
            {
                "name": "[value_if_false]",
                "desc": "The value to return if the condition is FALSE."
            }
        ]
    },
    {
        "name": "SUMIF",
        "category": "Math & Trig",
        "syntax": "=SUMIF(range, criteria, [sum_range])",
        "summary": "Adds the cells specified by a given criteria.",
        "common_errors": [
            "Range sizes do not match",
            "Criteria string syntax issues"
        ],
        "best_practice": "Use wildcard characters (*, ?) for partial matching in criteria.",
        "parameters": [
            {
                "name": "range",
                "desc": "The range of cells you want evaluated by criteria."
            },
            {
                "name": "criteria",
                "desc": "The condition that defines which cells will be added."
            },
            {
                "name": "[sum_range]",
                "desc": "The actual cells to add, if different from range."
            }
        ]
    },
    {
        "name": "XLOOKUP",
        "category": "Lookup & Reference",
        "syntax": "=XLOOKUP(lookup_value, lookup_array, return_array, [if_not_found], [match_mode], [search_mode])",
        "summary": "Searches a range or array for a match and returns the corresponding item from a second range or array. A modern, more flexible replacement for VLOOKUP.",
        "common_errors": [
            "#N/A (Value not found and no if_not_found specified)",
            "#VALUE! (lookup_array and return_array have different sizes)",
            "#NAME? (Using XLOOKUP in older Excel versions that don't support it)"
        ],
        "best_practice": "Always provide the if_not_found argument to avoid ugly #N/A errors. XLOOKUP can look left (unlike VLOOKUP) and defaults to exact match, so no need to remember FALSE.",
        "parameters": [
            {
                "name": "lookup_value",
                "desc": "The value to search for."
            },
            {
                "name": "lookup_array",
                "desc": "The array or range to search in."
            },
            {
                "name": "return_array",
                "desc": "The array or range to return from."
            },
            {
                "name": "[if_not_found]",
                "desc": "Custom text to return if no match is found."
            },
            {
                "name": "[match_mode]",
                "desc": "0 = exact (default), -1 = exact or next smaller, 1 = exact or next larger, 2 = wildcard."
            },
            {
                "name": "[search_mode]",
                "desc": "1 = first to last (default), -1 = last to first, 2 = binary ascending, -2 = binary descending."
            }
        ]
    },
    {
        "name": "SUM",
        "category": "Math & Trig",
        "syntax": "=SUM(number1, [number2], ...)",
        "summary": "Adds all the numbers in a range of cells. The most fundamental and frequently used Excel function.",
        "common_errors": [
            "Including text or error cells in the range (silently ignored or causes #VALUE!)",
            "Accidentally summing hidden/filtered rows",
            "Circular reference when SUM range includes the cell containing the formula"
        ],
        "best_practice": "Use SUBTOTAL(109, range) instead of SUM if you need to ignore hidden/filtered rows. For adding only numbers that meet criteria, use SUMIF or SUMIFS.",
        "parameters": [
            {
                "name": "number1",
                "desc": "The first number, cell reference, or range to add."
            },
            {
                "name": "[number2]",
                "desc": "Additional numbers, cell references, or ranges to add (up to 255 arguments)."
            }
        ]
    },
    {
        "name": "COUNTIF",
        "category": "Statistical",
        "syntax": "=COUNTIF(range, criteria)",
        "summary": "Counts the number of cells within a range that meet the given condition.",
        "common_errors": [
            "#VALUE! (criteria string longer than 255 characters)",
            "Incorrect wildcard usage (* and ? not working as expected)",
            "Counting text as numbers or vice versa due to data type mismatch"
        ],
        "best_practice": "Use COUNTIFS for multiple conditions. Wrap criteria with comparison operators in quotes, e.g., \">100\". Use \"*\" to count all non-empty text cells.",
        "parameters": [
            {
                "name": "range",
                "desc": "The range of cells to count."
            },
            {
                "name": "criteria",
                "desc": "The condition that defines which cells to count. Can be a number, expression, text, or cell reference."
            }
        ]
    },
    {
        "name": "INDEX",
        "category": "Lookup & Reference",
        "syntax": "=INDEX(array, row_num, [col_num])",
        "summary": "Returns a value or reference of the cell at the intersection of a particular row and column in a given range.",
        "common_errors": [
            "#REF! (row_num or col_num is outside the array bounds)",
            "#VALUE! (non-numeric row_num or col_num)",
            "Returning the wrong value when array dimensions are incorrect"
        ],
        "best_practice": "Pair INDEX with MATCH for a powerful, flexible lookup that can search in any direction — the classic INDEX/MATCH combo is more versatile than VLOOKUP.",
        "parameters": [
            {
                "name": "array",
                "desc": "A range of cells or an array constant."
            },
            {
                "name": "row_num",
                "desc": "The row position in the array from which to return a value."
            },
            {
                "name": "[col_num]",
                "desc": "The column position in the array from which to return a value."
            }
        ]
    },
    {
        "name": "MATCH",
        "category": "Lookup & Reference",
        "syntax": "=MATCH(lookup_value, lookup_array, [match_type])",
        "summary": "Searches for a specified item in a range and returns its relative position. Often paired with INDEX for flexible lookups.",
        "common_errors": [
            "#N/A (lookup_value not found in lookup_array)",
            "Data not sorted when using match_type 1 or -1",
            "Confusing the returned position number with the actual cell row number"
        ],
        "best_practice": "Use match_type 0 for exact match. The position returned is relative to lookup_array, not the worksheet — remember this when combining with INDEX.",
        "parameters": [
            {
                "name": "lookup_value",
                "desc": "The value you want to find in lookup_array."
            },
            {
                "name": "lookup_array",
                "desc": "A single row or column range to search."
            },
            {
                "name": "[match_type]",
                "desc": "1 = less than (default, data must be ascending), 0 = exact match, -1 = greater than (data must be descending)."
            }
        ]
    },
    {
        "name": "AVERAGE",
        "category": "Statistical",
        "syntax": "=AVERAGE(number1, [number2], ...)",
        "summary": "Returns the arithmetic mean (average) of the arguments. Ignores text, logical values, and empty cells.",
        "common_errors": [
            "Including cells with 0 when you meant to exclude blank cells (0 is counted, blank is not)",
            "#DIV/0! (all cells in range are empty or contain text)",
            "Hidden rows being included in the average"
        ],
        "best_practice": "Use AVERAGEIF or AVERAGEIFS to calculate averages with conditions. If you need to exclude zeros, use AVERAGEIF(range, \"<>0\").",
        "parameters": [
            {
                "name": "number1",
                "desc": "The first number, cell reference, or range for which you want the average."
            },
            {
                "name": "[number2]",
                "desc": "Additional numbers, cell references, or ranges (up to 255 arguments)."
            }
        ]
    },
    {
        "name": "IFERROR",
        "category": "Logical",
        "syntax": "=IFERROR(value, value_if_error)",
        "summary": "Returns value_if_error if the formula evaluates to an error; otherwise, returns the result of the formula. Catches all error types (#N/A, #VALUE!, #REF!, #DIV/0!, #NUM!, #NAME?, #NULL!).",
        "common_errors": [
            "Hiding genuine errors that should be investigated (masking bugs)",
            "Wrapping formulas that rarely error, adding unnecessary overhead",
            "Using IFERROR when IFNA would be more precise (only catch #N/A)"
        ],
        "best_practice": "Use IFNA instead of IFERROR when wrapping VLOOKUP/XLOOKUP — it only catches #N/A and lets other errors (which indicate real problems) surface.",
        "parameters": [
            {
                "name": "value",
                "desc": "The formula or value to check for errors."
            },
            {
                "name": "value_if_error",
                "desc": "The value to return if an error is detected. Can be text, number, blank (\"\"), or another formula."
            }
        ]
    },
    {
        "name": "COUNTIFS",
        "category": "Statistical",
        "syntax": "=COUNTIFS(criteria_range1, criteria1, [criteria_range2, criteria2], ...)",
        "summary": "Counts the number of cells that meet multiple criteria across multiple ranges. All criteria must be met (AND logic).",
        "common_errors": [
            "Criteria ranges have different sizes (all ranges must have the same dimensions)",
            "Date criteria not formatted correctly (wrap in DATE() or use quotes)",
            "Using OR logic by mistake — COUNTIFS uses AND logic only"
        ],
        "best_practice": "For OR logic across criteria, add multiple COUNTIFS together. Use date comparisons like \">\"&DATE(2024,1,1). All criteria_range arguments must have equal row/column counts.",
        "parameters": [
            {
                "name": "criteria_range1",
                "desc": "The first range in which to evaluate the associated criteria."
            },
            {
                "name": "criteria1",
                "desc": "The criteria for criteria_range1 (number, expression, text, or cell reference)."
            },
            {
                "name": "[criteria_range2]",
                "desc": "Additional ranges (up to 127 pairs)."
            },
            {
                "name": "[criteria2]",
                "desc": "The criteria for criteria_range2."
            }
        ]
    },
    {
        "name": "SUMIFS",
        "category": "Math & Trig",
        "syntax": "=SUMIFS(sum_range, criteria_range1, criteria1, [criteria_range2, criteria2], ...)",
        "summary": "Adds cells in a range that meet multiple criteria. Unlike SUMIF, the sum_range is the FIRST argument.",
        "common_errors": [
            "Confusing argument order with SUMIF (SUMIFS puts sum_range FIRST)",
            "Criteria ranges and sum_range have different sizes",
            "#VALUE! when using array formulas incorrectly with SUMIFS"
        ],
        "best_practice": "Remember: SUMIFS(sum_range, criteria_range, criteria) — sum_range comes first! This is different from SUMIF. For date ranges, use paired criteria like \">=\"&start_date and \"<=\"&end_date.",
        "parameters": [
            {
                "name": "sum_range",
                "desc": "The range of cells to sum."
            },
            {
                "name": "criteria_range1",
                "desc": "The range to evaluate with criteria1."
            },
            {
                "name": "criteria1",
                "desc": "The criteria for criteria_range1."
            },
            {
                "name": "[criteria_range2]",
                "desc": "Additional range/criteria pairs (up to 127)."
            },
            {
                "name": "[criteria2]",
                "desc": "The criteria for criteria_range2."
            }
        ]
    },
    {
        "name": "CONCATENATE",
        "category": "Text",
        "syntax": "=CONCATENATE(text1, [text2], ...) or =TEXTJOIN(delimiter, ignore_empty, text1, [text2], ...)",
        "summary": "Joins two or more text strings into one. TEXTJOIN (Excel 2019+) is the modern upgrade, letting you specify a delimiter and ignore empty cells.",
        "common_errors": [
            "Forgetting to add spaces or delimiters between joined text",
            "Numbers and dates not displaying correctly (need TEXT() function to format)",
            "#VALUE! (too many characters — cell limit is 32,767)"
        ],
        "best_practice": "Use TEXTJOIN instead of CONCATENATE for cleaner formulas. Or simply use the & operator: =A1&\" \"&B1. To format numbers/dates when joining, wrap them in TEXT().",
        "parameters": [
            {
                "name": "text1",
                "desc": "The first text string to join."
            },
            {
                "name": "[text2]",
                "desc": "Additional text strings to join (up to 255 for CONCATENATE, up to 252 for TEXTJOIN)."
            }
        ]
    },
    {
        "name": "LEFT",
        "category": "Text",
        "syntax": "=LEFT(text, [num_chars]) / =RIGHT(text, [num_chars]) / =MID(text, start_num, num_chars)",
        "summary": "Extract characters from text: LEFT from the beginning, RIGHT from the end, MID from any position. Essential for parsing and cleaning data.",
        "common_errors": [
            "#VALUE! (num_chars is negative or start_num is less than 1)",
            "Extracting wrong characters because of invisible spaces (use TRIM first)",
            "Getting unexpected results with multi-byte characters (e.g., emojis, CJK)"
        ],
        "best_practice": "Combine with FIND or SEARCH to dynamically locate delimiters: =LEFT(A1, FIND(\"-\", A1)-1) extracts text before a dash. Use TRIM and CLEAN to remove hidden characters first.",
        "parameters": [
            {
                "name": "text",
                "desc": "The text string from which to extract characters."
            },
            {
                "name": "[num_chars]",
                "desc": "Number of characters to extract (defaults to 1 for LEFT/RIGHT)."
            },
            {
                "name": "start_num",
                "desc": "(MID only) The position of the first character to extract."
            }
        ]
    },
    {
        "name": "LEN",
        "category": "Text",
        "syntax": "=LEN(text) / =TRIM(text)",
        "summary": "LEN returns the number of characters in a text string. TRIM removes all extra spaces from text, leaving only single spaces between words.",
        "common_errors": [
            "LEN counting invisible characters (line breaks, non-breaking spaces) that aren't visible",
            "TRIM not removing non-breaking spaces (use SUBSTITUTE(A1, CHAR(160), \"\") for those)",
            "Unexpected LEN results with numbers stored as text"
        ],
        "best_practice": "Use LEN to validate data (e.g., check if phone numbers have correct digits). Chain TRIM with CLEAN to remove both extra spaces and non-printable characters: =TRIM(CLEAN(A1)).",
        "parameters": [
            {
                "name": "text",
                "desc": "The text string whose length you want (LEN) or from which to remove extra spaces (TRIM)."
            }
        ]
    },
    {
        "name": "FILTER",
        "category": "Dynamic Array",
        "syntax": "=FILTER(array, include, [if_empty])",
        "summary": "Filters a range of data based on criteria you define. Returns results that automatically spill into neighboring cells. A game-changer introduced in Excel 365/2021.",
        "common_errors": [
            "#CALC! (no rows meet the criteria and if_empty is not provided)",
            "#SPILL! (cells where results would spill are not empty)",
            "#VALUE! (include array dimensions don't match the array argument)"
        ],
        "best_practice": "Always provide the if_empty argument (e.g., \"No results found\") to prevent #CALC! errors. Combine multiple criteria with * (AND) or + (OR): =FILTER(A:C, (B:B=\"Sales\")*(C:C>1000)).",
        "parameters": [
            {
                "name": "array",
                "desc": "The range or array to filter."
            },
            {
                "name": "include",
                "desc": "A Boolean array (TRUE/FALSE) the same height as array. Only rows where include is TRUE are returned."
            },
            {
                "name": "[if_empty]",
                "desc": "Value to return when no rows meet the criteria."
            }
        ]
    },
    {
        "name": "UNIQUE",
        "category": "Dynamic Array",
        "syntax": "=UNIQUE(array, [by_col], [exactly_once])",
        "summary": "Returns a list of unique values from a range or array. Automatically spills results. Perfect for removing duplicates without altering original data.",
        "common_errors": [
            "#SPILL! (destination cells are not empty)",
            "Case sensitivity — UNIQUE treats 'Apple' and 'apple' as the same in most contexts",
            "Extra blank rows being included as unique values"
        ],
        "best_practice": "Combine with SORT for a clean, alphabetized list of unique values: =SORT(UNIQUE(A2:A100)). Use exactly_once=TRUE to find values that appear only once (great for finding orphan data).",
        "parameters": [
            {
                "name": "array",
                "desc": "The range or array from which to extract unique values."
            },
            {
                "name": "[by_col]",
                "desc": "TRUE = compare by column, FALSE = compare by row (default)."
            },
            {
                "name": "[exactly_once]",
                "desc": "TRUE = return only values appearing exactly once. FALSE = return all distinct values (default)."
            }
        ]
    },
    {
        "name": "LET",
        "category": "Logical",
        "syntax": "=LET(name1, value1, [name2, value2], ..., calculation)",
        "summary": "Assigns names to calculation results inside a formula, making complex formulas readable and faster by avoiding repeated calculations.",
        "common_errors": [
            "#NAME? (using LET in older Excel versions — requires Excel 365/2021+)",
            "Forgetting the final calculation argument (LET needs at least one name/value pair AND a calculation)",
            "#VALUE! (name conflicts with existing cell references like A1, B2)"
        ],
        "best_practice": "Use LET to name intermediate results: =LET(revenue, SUM(B:B), cost, SUM(C:C), revenue-cost) is cleaner and faster than =SUM(B:B)-SUM(C:C) when those ranges are used multiple times.",
        "parameters": [
            {
                "name": "name1",
                "desc": "The first variable name (cannot conflict with cell references)."
            },
            {
                "name": "value1",
                "desc": "The value or formula assigned to name1."
            },
            {
                "name": "calculation",
                "desc": "The final calculation that uses the defined names. This is the result returned by LET."
            }
        ]
    },
    {
        "name": "SORT",
        "category": "Dynamic Array",
        "syntax": "=SORT(array, [sort_index], [sort_order], [by_col])",
        "summary": "Sorts the contents of a range or array. Results spill automatically. No more manual Sort buttons — your data stays dynamically sorted.",
        "common_errors": [
            "#SPILL! (destination cells are not empty)",
            "#VALUE! (sort_index exceeds the number of columns/rows in the array)",
            "Sorting by the wrong column because sort_index is relative to the array, not the worksheet"
        ],
        "best_practice": "Combine SORT with FILTER for a sorted, filtered view of your data: =SORT(FILTER(A:D, C:C>100), 3, -1). Use sort_order -1 for descending (largest to smallest or Z to A).",
        "parameters": [
            {
                "name": "array",
                "desc": "The range or array to sort."
            },
            {
                "name": "[sort_index]",
                "desc": "The column (or row) number to sort by. Default is 1."
            },
            {
                "name": "[sort_order]",
                "desc": "1 = ascending (default), -1 = descending."
            },
            {
                "name": "[by_col]",
                "desc": "TRUE = sort by column (left to right), FALSE = sort by row (default, top to bottom)."
            }
        ]
    },
    {
        "name": "LAMBDA",
        "category": "Advanced",
        "syntax": "=LAMBDA([parameter1, parameter2, ...], calculation)",
        "summary": "Creates custom, reusable functions without VBA or macros. Define your own formula once, name it in the Name Manager, and use it like any built-in function.",
        "common_errors": [
            "#CALC! (LAMBDA called without being assigned to a name — it won't work inline without being invoked)",
            "#NAME? (not available in older Excel versions — requires Excel 365)",
            "Recursive LAMBDAs causing stack overflow with large datasets"
        ],
        "best_practice": "Define LAMBDA in Name Manager (Formulas > Name Manager) to create reusable custom functions. Example: Create a 'TAX' function =LAMBDA(price, rate, price * rate) then use =TAX(A1, 0.1) anywhere.",
        "parameters": [
            {
                "name": "[parameter]",
                "desc": "Input parameters for your custom function. Up to 253 parameters."
            },
            {
                "name": "calculation",
                "desc": "The formula to execute, using the parameters. This is the result returned."
            }
        ]
    },
    {
        "name": "TRIM",
        "category": "Text",
        "syntax": "=TRIM(text)",
        "summary": "Removes all extra spaces from text strings, leaving only single spaces between words. Essential for cleaning data pasted from other sources.",
        "common_errors": [
            "Expecting TRIM to remove non-breaking spaces (CHAR(160)) – it only removes standard spaces (CHAR(32)).",
            "TRIM not working on numbers formatted as text.",
            "Confusing TRIM with CLEAN (which removes non-printable characters)."
        ],
        "best_practice": "Use =TRIM(CLEAN(A1)) to remove both extra spaces and unprintable characters. For web data, use =SUBSTITUTE(A1, CHAR(160), \" \") to handle non-breaking spaces.",
        "parameters": [
            {
                "name": "text",
                "desc": "The text from which you want to remove spaces."
            }
        ]
    },
    {
        "name": "TEXT",
        "category": "Text",
        "syntax": "=TEXT(value, format_text)",
        "summary": "Converts a number to text in a specific format. Essential for embedding dates or numbers inside text strings while keeping their formatting.",
        "common_errors": [
            "Using TEXT for calculations (the result is text, not a number, so math functions won't work on it)",
            "Incorrect format codes (e.g., using 'm' for minutes instead of 'mm' after 'h')",
            "Hardcoding formats that don't adapt to system locale changes"
        ],
        "best_practice": "Use TEXT only for display purposes, like joining a date with text: =\"Today is \" & TEXT(TODAY(), \"dd-mmm-yyyy\"). Keep raw data as numbers for calculations.",
        "parameters": [
            {
                "name": "value",
                "desc": "The numeric value you want to format."
            },
            {
                "name": "format_text",
                "desc": "The format code in quotation marks (e.g., \"0.00%\", \"dd/mm/yyyy\")."
            }
        ]
    },
    {
        "name": "MID",
        "category": "Text",
        "syntax": "=MID(text, start_num, num_chars)",
        "summary": "Extracts a specific number of characters from the middle of a text string, starting at the position you specify.",
        "common_errors": [
            "Start_num is 1 (this acts like LEFT, but works)",
            "Start_num is greater than text length (returns empty text)",
            "Num_chars is negative (returns #VALUE! error)"
        ],
        "best_practice": "Combine with FIND or SEARCH to extract text between delimiters (e.g., getting a domain name from an email address).",
        "parameters": [
            {
                "name": "text",
                "desc": "The text string containing the characters you want to extract."
            },
            {
                "name": "start_num",
                "desc": "The position of the first character you want to extract in text (1-based)."
            },
            {
                "name": "num_chars",
                "desc": "The number of characters you want to extract."
            }
        ]
    },
    {
        "name": "RIGHT",
        "category": "Text",
        "syntax": "=RIGHT(text, [num_chars])",
        "summary": "Extracts the last character or characters from a text string, based on the number of characters you specify.",
        "common_errors": [
            "Num_chars is greater than text length (returns whole text)",
            "Trailing spaces in original text (causes RIGHT to return spaces instead of desired characters - use TRIM first)"
        ],
        "best_practice": "Use LEN to calculate num_chars dynamically if you need everything after a specific separator.",
        "parameters": [
            {
                "name": "text",
                "desc": "The text string containing the characters you want to extract."
            },
            {
                "name": "num_chars",
                "desc": "Optional. The number of characters you want to extract. Default is 1."
            }
        ]
    },
    {
        "name": "SEARCH",
        "category": "Text",
        "syntax": "=SEARCH(find_text, within_text, [start_num])",
        "summary": "Finds the starting position of a text string within another text string. Unlike FIND, SEARCH is not case-sensitive.",
        "common_errors": [
            "Confusing with FIND (SEARCH ignores case, FIND matches case)",
            "Using wildcards incorrectly (*, ?)",
            "Start_num is 0 or negative (returns #VALUE! error)"
        ],
        "best_practice": "Use with ISNUMBER to check if a specific text exists in a cell: =ISNUMBER(SEARCH(\"text\", A1)) returns TRUE or FALSE.",
        "parameters": [
            {
                "name": "find_text",
                "desc": "The text you want to find."
            },
            {
                "name": "within_text",
                "desc": "The text in which you want to search for the find_text."
            },
            {
                "name": "start_num",
                "desc": "Optional. The character number in within_text at which you want to start searching."
            }
        ]
    },
    {
        "name": "DATE",
        "category": "Date & Time",
        "syntax": "=DATE(year, month, day)",
        "summary": "Creates a valid Excel date from individual year, month, and day numbers. Essential for assembling dates from separate columns.",
        "common_errors": [
            "Year is less than 1900 (Excel dates start from 1900)",
            "Month is greater than 12 (Excel adds the extra months to the year, e.g., Month 13 becomes January of next year)",
            "Day is greater than days in month (Excel adds extra days to next month)"
        ],
        "best_practice": "Use DATE to safely construct dates that won't be misinterpreted as text, especially when importing data from CSVs.",
        "parameters": [
            {
                "name": "year",
                "desc": "The year number (e.g., 2023). Excel interprets small numbers according to system settings."
            },
            {
                "name": "month",
                "desc": "The month number (1 for Jan, 12 for Dec). Greater values roll over to next year."
            },
            {
                "name": "day",
                "desc": "The day number. Greater values roll over to next month."
            }
        ]
    },
    {
        "name": "HLOOKUP",
        "category": "Lookup & Reference",
        "syntax": "=HLOOKUP(lookup_value, table_array, row_index_num, [range_lookup])",
        "summary": "Searches for a value in the top row of a table or an array of values, and then returns a value in the same column from a row you specify in the table or array.",
        "common_errors": [
            "#N/A (Value not found)",
            "#REF! (row_index_num is greater than the number of rows in table_array)",
            "#VALUE! (row_index_num is less than 1)"
        ],
        "best_practice": "Use XLOOKUP instead if you have Excel 365 or 2021. It's more versatile and easier to use.",
        "parameters": [
            {
                "name": "lookup_value",
                "desc": "The value to be found in the first row of the table."
            },
            {
                "name": "table_array",
                "desc": "The range of cells that contains the data."
            },
            {
                "name": "row_index_num",
                "desc": "The row number in table_array from which the matching value will be returned."
            },
            {
                "name": "[range_lookup]",
                "desc": "A logical value that specifies whether you want HLOOKUP to find an exact match (FALSE) or an approximate match (TRUE)."
            }
        ]
    },
    {
        "name": "NETWORKDAYS",
        "category": "Date & Time",
        "syntax": "NETWORKDAYS(start_date, end_date, [holidays])",
        "summary": "Calculates the number of whole working days between two dates, excluding weekends and optional holidays.",
        "common_errors": [
            "#VALUE! if start_date or end_date are not valid dates.",
            "Incorrect holiday count if holidays are not properly formatted."
        ],
        "best_practice": "Store holidays in a named range for easier maintenance and readability.",
        "parameters": [
            {
                "name": "start_date",
                "desc": "The start date for the calculation."
            },
            {
                "name": "end_date",
                "desc": "The end date for the calculation."
            },
            {
                "name": "holidays",
                "desc": "An optional range of one or more dates to exclude from the working calendar."
            }
        ]
    },
    {
        "name": "EDATE",
        "category": "Date & Time",
        "syntax": "EDATE(start_date, months)",
        "summary": "Returns the serial number of the date that is the indicated number of months before or after the start date.",
        "common_errors": [
            "#VALUE! if start_date is not a valid date.",
            "#NUM! if the resulting date is outside the valid date range."
        ],
        "best_practice": "Use EDATE to calculate maturity dates or other due dates that fall on the same day of the month.",
        "parameters": [
            {
                "name": "start_date",
                "desc": "The start date as a valid Excel date."
            },
            {
                "name": "months",
                "desc": "The number of months before or after start_date. A positive value for future dates, negative for past dates."
            }
        ]
    },
    {
        "name": "EOMONTH",
        "category": "Date & Time",
        "syntax": "EOMONTH(start_date, months)",
        "summary": "Returns the serial number of the last day of the month before or after a specified number of months.",
        "common_errors": [
            "#VALUE! if start_date is not a valid date.",
            "#NUM! if the resulting date is outside the valid date range."
        ],
        "best_practice": "Useful for calculating month-end due dates or fiscal period ends.",
        "parameters": [
            {
                "name": "start_date",
                "desc": "The start date as a valid Excel date."
            },
            {
                "name": "months",
                "desc": "The number of months before or after start_date. A positive value for future dates, negative for past dates."
            }
        ]
    },
    {
        "name": "WORKDAY",
        "category": "Date & Time",
        "syntax": "WORKDAY(start_date, days, [holidays])",
        "summary": "Returns the date before or after a specified number of working days, excluding weekends and optional holidays.",
        "common_errors": [
            "#VALUE! if start_date is not a valid date.",
            "#NUM! if the resulting date is outside the valid date range."
        ],
        "best_practice": "Ideal for calculating project due dates that only account for business days.",
        "parameters": [
            {
                "name": "start_date",
                "desc": "The start date as a valid Excel date."
            },
            {
                "name": "days",
                "desc": "The number of non-weekend and non-holiday days before or after start_date. Positive for future, negative for past."
            },
            {
                "name": "holidays",
                "desc": "An optional range of one or more dates to exclude from the working calendar."
            }
        ]
    },
    {
        "name": "TODAY",
        "category": "Date & Time",
        "syntax": "TODAY()",
        "summary": "Returns the current date, formatted as a date.",
        "common_errors": [
            "Not recalculating if the spreadsheet isn't opened or forced to recalculate."
        ],
        "best_practice": "Use TODAY() for calculating ages or deadlines relative to the current date, but be aware it updates daily.",
        "parameters": []
    },
    {
        "name": "NOW",
        "category": "Date & Time",
        "syntax": "NOW()",
        "summary": "Returns the current date and time, formatted as a date and time.",
        "common_errors": [
            "Not recalculating if the spreadsheet isn't opened or forced to recalculate."
        ],
        "best_practice": "Useful for timestamping entries, but remember it's volatile and recalculates frequently.",
        "parameters": []
    },
    {
        "name": "YEAR",
        "category": "Date & Time",
        "syntax": "YEAR(serial_number)",
        "summary": "Returns the year corresponding to a date, as an integer from 1900 to 9999.",
        "common_errors": [
            "#VALUE! if the argument is not a valid date serial number.",
            "Returning unexpected year if the cell is not formatted as a date."
        ],
        "best_practice": "Always ensure the input 'serial_number' refers to a properly formatted date.",
        "parameters": [
            {
                "name": "serial_number",
                "desc": "A valid date serial number or a cell reference containing a date."
            }
        ]
    },
    {
        "name": "MONTH",
        "category": "Date & Time",
        "syntax": "MONTH(serial_number)",
        "summary": "Returns the month corresponding to a date, as an integer from 1 (January) to 12 (December).",
        "common_errors": [
            "#VALUE! if the argument is not a valid date serial number.",
            "Returning unexpected month if the cell is not formatted as a date."
        ],
        "best_practice": "Combine with other date functions for detailed date analysis.",
        "parameters": [
            {
                "name": "serial_number",
                "desc": "A valid date serial number or a cell reference containing a date."
            }
        ]
    },
    {
        "name": "DAY",
        "category": "Date & Time",
        "syntax": "DAY(serial_number)",
        "summary": "Returns the day of the month corresponding to a date, as an integer from 1 to 31.",
        "common_errors": [
            "#VALUE! if the argument is not a valid date serial number.",
            "Returning unexpected day if the cell is not formatted as a date."
        ],
        "best_practice": "Extract day numbers for scheduling or reporting on specific days of the month.",
        "parameters": [
            {
                "name": "serial_number",
                "desc": "A valid date serial number or a cell reference containing a date."
            }
        ]
    },
    {
        "name": "WEEKDAY",
        "category": "Date & Time",
        "syntax": "WEEKDAY(serial_number, [return_type])",
        "summary": "Returns the day of the week for a given date as a number (1 to 7).",
        "common_errors": [
            "#VALUE! if serial_number is not a valid date.",
            "#NUM! if return_type is outside the allowed range."
        ],
        "best_practice": "Use the 'return_type' argument to match your preferred numbering system for the week (e.g., 1 for Sunday=1, 2 for Monday=1).",
        "parameters": [
            {
                "name": "serial_number",
                "desc": "A valid date serial number or a cell reference containing a date."
            },
            {
                "name": "return_type",
                "desc": "Optional. A number that determines the type of return value (e.g., 1=Sunday-Saturday, 2=Monday-Sunday)."
            }
        ]
    },
    {
        "name": "WEEKNUM",
        "category": "Date & Time",
        "syntax": "WEEKNUM(serial_number, [return_type])",
        "summary": "Returns the week number of a specific date (1 to 52 or 53).",
        "common_errors": [
            "#VALUE! if serial_number is not a valid date.",
            "#NUM! if return_type is outside the allowed range."
        ],
        "best_practice": "Specify return_type (e.g., 1 for week starts Sunday, 2 for week starts Monday) to ensure consistency with your reporting standards.",
        "parameters": [
            {
                "name": "serial_number",
                "desc": "A valid date serial number or a cell reference containing a date."
            },
            {
                "name": "return_type",
                "desc": "Optional. A number that determines the day the week begins (e.g., 1 or omitted=Sunday, 2=Monday)."
            }
        ]
    },
    {
        "name": "HOUR",
        "category": "Date & Time",
        "syntax": "HOUR(serial_number)",
        "summary": "Returns the hour as an integer from 0 (12:00 A.M.) to 23 (11:00 P.M.) from a time value.",
        "common_errors": [
            "#VALUE! if the argument is not a valid time serial number or date-time string."
        ],
        "best_practice": "Useful for breaking down time data for analysis, such as peak activity hours.",
        "parameters": [
            {
                "name": "serial_number",
                "desc": "A valid time serial number or a cell reference containing a time/date-time."
            }
        ]
    },
    {
        "name": "MINUTE",
        "category": "Date & Time",
        "syntax": "MINUTE(serial_number)",
        "summary": "Returns the minute as an integer from 0 to 59 from a time value.",
        "common_errors": [
            "#VALUE! if the argument is not a valid time serial number or date-time string."
        ],
        "best_practice": "Combine with HOUR and SECOND to reconstruct or analyze specific time points.",
        "parameters": [
            {
                "name": "serial_number",
                "desc": "A valid time serial number or a cell reference containing a time/date-time."
            }
        ]
    },
    {
        "name": "SECOND",
        "category": "Date & Time",
        "syntax": "SECOND(serial_number)",
        "summary": "Returns the second as an integer from 0 to 59 from a time value.",
        "common_errors": [
            "#VALUE! if the argument is not a valid time serial number or date-time string."
        ],
        "best_practice": "Useful for very granular time tracking and calculations.",
        "parameters": [
            {
                "name": "serial_number",
                "desc": "A valid time serial number or a cell reference containing a time/date-time."
            }
        ]
    },
    {
        "name": "TIME",
        "category": "Date & Time",
        "syntax": "TIME(hour, minute, second)",
        "summary": "Returns the decimal number for a particular time, representing a fraction of a day.",
        "common_errors": [
            "#VALUE! if any argument is non-numeric.",
            "Returning unexpected time if hour/minute/second values are out of range (e.g., minute > 59)."
        ],
        "best_practice": "Use TIME to convert separate hour, minute, and second values into a valid Excel time format.",
        "parameters": [
            {
                "name": "hour",
                "desc": "A number from 0 to 23 representing the hour."
            },
            {
                "name": "minute",
                "desc": "A number from 0 to 59 representing the minute."
            },
            {
                "name": "second",
                "desc": "A number from 0 to 59 representing the second."
            }
        ]
    },
    {
        "name": "YEARFRAC",
        "category": "Date & Time",
        "syntax": "YEARFRAC(start_date, end_date, [basis])",
        "summary": "Calculates the fraction of the year represented by the number of whole days between two dates.",
        "common_errors": [
            "#VALUE! if start_date or end_date are not valid dates.",
            "#NUM! if basis is outside the accepted range (0-4)."
        ],
        "best_practice": "Specify the 'basis' argument to ensure accurate calculations according to financial or accounting conventions.",
        "parameters": [
            {
                "name": "start_date",
                "desc": "The start date as a valid Excel date."
            },
            {
                "name": "end_date",
                "desc": "The end date as a valid Excel date."
            },
            {
                "name": "basis",
                "desc": "Optional. The type of day count basis to use (e.g., 0=US (NASD) 30/360, 1=Actual/Actual)."
            }
        ]
    },
    {
        "name": "DATEDIF",
        "category": "Date & Time",
        "syntax": "DATEDIF(start_date, end_date, unit)",
        "summary": "Calculates the number of days, months, or years between two dates.",
        "common_errors": [
            "#VALUE! if start_date or end_date are not valid dates.",
            "Returning incorrect value if unit is misspelled or invalid.",
            "Error if start_date is later than end_date."
        ],
        "best_practice": "Be precise with the 'unit' argument (e.g., 'Y' for years, 'M' for months, 'D' for days) to get the desired result.",
        "parameters": [
            {
                "name": "start_date",
                "desc": "The start date for the calculation."
            },
            {
                "name": "end_date",
                "desc": "The end date for the calculation."
            },
            {
                "name": "unit",
                "desc": "The interval unit ('Y', 'M', 'D', 'YM', 'YD', 'MD')."
            }
        ]
    },
    {
        "name": "SEQUENCE",
        "category": "Dynamic Array",
        "syntax": "SEQUENCE(rows, [columns], [start], [step])",
        "summary": "Generates a list of sequential numbers in an array, such as 1, 2, 3, 4, 5.",
        "common_errors": [
            "#VALUE! if arguments are non-numeric.",
            "#SPILL! if the resulting array cannot fit into adjacent cells."
        ],
        "best_practice": "Use SEQUENCE to create dynamic data ranges or helper columns that automatically adjust with your data.",
        "parameters": [
            {
                "name": "rows",
                "desc": "The number of rows to return."
            },
            {
                "name": "columns",
                "desc": "Optional. The number of columns to return (defaults to 1)."
            },
            {
                "name": "start",
                "desc": "Optional. The starting number (defaults to 1)."
            },
            {
                "name": "step",
                "desc": "Optional. The increment value for each subsequent value (defaults to 1)."
            }
        ]
    },
    {
        "name": "RANDARRAY",
        "category": "Dynamic Array",
        "syntax": "RANDARRAY([rows], [columns], [min], [max], [whole])",
        "summary": "Generates an array of random numbers, specified by the number of rows and columns.",
        "common_errors": [
            "#VALUE! if arguments are non-numeric.",
            "#SPILL! if the resulting array cannot fit into adjacent cells."
        ],
        "best_practice": "Use RANDARRAY for simulations or generating sample data, but remember it's volatile and recalculates on every change.",
        "parameters": [
            {
                "name": "rows",
                "desc": "Optional. The number of rows to return."
            },
            {
                "name": "columns",
                "desc": "Optional. The number of columns to return."
            },
            {
                "name": "min",
                "desc": "Optional. The smallest number in the array."
            },
            {
                "name": "max",
                "desc": "Optional. The largest number in the array."
            },
            {
                "name": "whole",
                "desc": "Optional. TRUE for whole numbers, FALSE for decimals."
            }
        ]
    },
    {
        "name": "SORTBY",
        "category": "Dynamic Array",
        "syntax": "SORTBY(array, by_array1, [sort_order1], [by_array2, sort_order2], ...)",
        "summary": "Sorts the contents of a range or array based on the values in a corresponding range or array.",
        "common_errors": [
            "#VALUE! if the 'array' and 'by_array' arguments have incompatible dimensions.",
            "#SPILL! if the resulting array cannot fit into adjacent cells."
        ],
        "best_practice": "Use SORTBY when you need to sort a dataset by multiple columns with different sort orders (ascending/descending).",
        "parameters": [
            {
                "name": "array",
                "desc": "The array or range to sort."
            },
            {
                "name": "by_array1",
                "desc": "The array or range to sort by."
            },
            {
                "name": "sort_order1",
                "desc": "Optional. 1 for ascending, -1 for descending (defaults to 1)."
            },
            {
                "name": "by_array2",
                "desc": "Optional. A second array or range to sort by."
            },
            {
                "name": "sort_order2",
                "desc": "Optional. Sort order for the second array (1 for ascending, -1 for descending)."
            }
        ]
    },
    {
        "name": "XMATCH",
        "category": "Dynamic Array / Lookup & Reference",
        "syntax": "XMATCH(lookup_value, lookup_array, [match_mode], [search_mode])",
        "summary": "Searches for a specified item in an array or range of cells and then returns the item's relative position.",
        "common_errors": [
            "#N/A if lookup_value is not found in lookup_array.",
            "#VALUE! if match_mode or search_mode are invalid."
        ],
        "best_practice": "Use XMATCH as a flexible alternative to MATCH, especially when needing approximate matches or reverse searches.",
        "parameters": [
            {
                "name": "lookup_value",
                "desc": "The value to search for."
            },
            {
                "name": "lookup_array",
                "desc": "The array or range to search within."
            },
            {
                "name": "match_mode",
                "desc": "Optional. 0 for exact match (default), -1 for exact match or next smaller, 1 for exact match or next larger, 2 for wildcard match."
            },
            {
                "name": "search_mode",
                "desc": "Optional. 1 for search from first to last (default), -1 for search from last to first, 2 for binary search ascending, -2 for binary search descending."
            }
        ]
    },
    {
        "name": "AND",
        "category": "Logical",
        "syntax": "AND(logical1, [logical2], ...)",
        "summary": "Returns TRUE if all its arguments evaluate to TRUE; returns FALSE if one or more arguments evaluate to FALSE.",
        "common_errors": [
            "#VALUE! if any argument is not a logical value or cannot be coerced to one."
        ],
        "best_practice": "Nest AND functions within IF statements to test multiple conditions simultaneously.",
        "parameters": [
            {
                "name": "logical1",
                "desc": "The first condition you want to test that can be TRUE or FALSE."
            },
            {
                "name": "logical2",
                "desc": "Additional conditions to test."
            }
        ]
    },
    {
        "name": "OR",
        "category": "Logical",
        "syntax": "OR(logical1, [logical2], ...)",
        "summary": "Returns TRUE if any argument evaluates to TRUE; returns FALSE if all arguments evaluate to FALSE.",
        "common_errors": [
            "#VALUE! if any argument is not a logical value or cannot be coerced to one."
        ],
        "best_practice": "Use OR when you need to check if at least one of several conditions is met.",
        "parameters": [
            {
                "name": "logical1",
                "desc": "The first condition you want to test that can be TRUE or FALSE."
            },
            {
                "name": "logical2",
                "desc": "Additional conditions to test."
            }
        ]
    },
    {
        "name": "NOT",
        "category": "Logical",
        "syntax": "NOT(logical)",
        "summary": "Reverses the logical value of its argument. If the argument is TRUE, NOT returns FALSE; if the argument is FALSE, NOT returns TRUE.",
        "common_errors": [
            "#VALUE! if the argument is not a logical value or cannot be coerced to one."
        ],
        "best_practice": "Use NOT to simplify complex logical conditions or to express the inverse of a condition clearly.",
        "parameters": [
            {
                "name": "logical",
                "desc": "A value or expression that can be TRUE or FALSE."
            }
        ]
    },
    {
        "name": "XOR",
        "category": "Logical",
        "syntax": "XOR(logical1, [logical2], ...)",
        "summary": "Returns a logical exclusive OR of all arguments. Returns TRUE if an odd number of arguments evaluate to TRUE.",
        "common_errors": [
            "#VALUE! if any argument is not a logical value or cannot be coerced to one."
        ],
        "best_practice": "Useful when you need to test if one and only one of several conditions is met.",
        "parameters": [
            {
                "name": "logical1",
                "desc": "The first condition you want to test that can be TRUE or FALSE."
            },
            {
                "name": "logical2",
                "desc": "Additional conditions to test."
            }
        ]
    },
    {
        "name": "IFS",
        "category": "Logical",
        "syntax": "IFS(logical_test1, value_if_true1, [logical_test2, value_if_true2], ...)",
        "summary": "Checks multiple conditions and returns a value corresponding to the first true condition.",
        "common_errors": [
            "#VALUE! if any logical_test is not a logical value.",
            "#N/A if none of the logical tests evaluate to TRUE."
        ],
        "best_practice": "Use IFS instead of nested IF statements for cleaner and more readable formulas when handling multiple conditions.",
        "parameters": [
            {
                "name": "logical_test1",
                "desc": "The first condition to test."
            },
            {
                "name": "value_if_true1",
                "desc": "The value to return if logical_test1 is TRUE."
            },
            {
                "name": "logical_test2",
                "desc": "The second condition to test."
            },
            {
                "name": "value_if_true2",
                "desc": "The value to return if logical_test2 is TRUE."
            }
        ]
    },
    {
        "name": "SWITCH",
        "category": "Logical",
        "syntax": "SWITCH(expression, value1, result1, [value2, result2], ..., [default])",
        "summary": "Evaluates one value (called the expression) against a list of values, and returns the first matching result.",
        "common_errors": [
            "#VALUE! if the expression or any value arguments are of incompatible types.",
            "#N/A if no match is found and no default value is provided."
        ],
        "best_practice": "Use SWITCH for cleaner code when you have an 'expression' that can have several possible discrete values, and you want to return a different result for each.",
        "parameters": [
            {
                "name": "expression",
                "desc": "The value or expression to compare against."
            },
            {
                "name": "value1",
                "desc": "The first value to compare against expression."
            },
            {
                "name": "result1",
                "desc": "The result if expression matches value1."
            },
            {
                "name": "default",
                "desc": "Optional. The value to return if no match is found."
            }
        ]
    },
    {
        "name": "TEXTJOIN",
        "category": "Text",
        "syntax": "TEXTJOIN(delimiter, ignore_empty, text1, [text2], ...)",
        "summary": "Combines text from multiple ranges and/or strings, and includes a delimiter you specify between each text item.",
        "common_errors": [
            "#VALUE! if the delimiter or ignore_empty arguments are of incorrect type.",
            "Empty strings if ignore_empty is FALSE and cells are empty."
        ],
        "best_practice": "Set 'ignore_empty' to TRUE to avoid unnecessary delimiters when combining text from potentially empty cells.",
        "parameters": [
            {
                "name": "delimiter",
                "desc": "The text string to place between text items."
            },
            {
                "name": "ignore_empty",
                "desc": "TRUE to ignore empty cells, FALSE to include them."
            },
            {
                "name": "text1",
                "desc": "The first text item to join."
            },
            {
                "name": "text2",
                "desc": "Additional text items to join."
            }
        ]
    },
    {
        "name": "SUBSTITUTE",
        "category": "Text",
        "syntax": "SUBSTITUTE(text, old_text, new_text, [instance_num])",
        "summary": "Replaces existing text with new text in a string.",
        "common_errors": [
            "#VALUE! if 'text' is not a text value."
        ],
        "best_practice": "Use SUBSTITUTE when you need to replace all occurrences of a specific string, or a particular instance if specified.",
        "parameters": [
            {
                "name": "text",
                "desc": "The text or reference to a cell containing text in which you want to substitute characters."
            },
            {
                "name": "old_text",
                "desc": "The text you want to replace."
            },
            {
                "name": "new_text",
                "desc": "The text you want to replace old_text with."
            },
            {
                "name": "instance_num",
                "desc": "Optional. Specifies which occurrence of old_text you want to replace. If omitted, all occurrences are replaced."
            }
        ]
    },
    {
        "name": "REPLACE",
        "category": "Text",
        "syntax": "REPLACE(old_text, start_num, num_chars, new_text)",
        "summary": "Replaces part of a text string, based on the number of characters you specify, with a different text string.",
        "common_errors": [
            "#VALUE! if any argument is not of the correct data type.",
            "Returning an unexpected string if start_num or num_chars are incorrect."
        ],
        "best_practice": "Use REPLACE when you know the exact position and length of the characters you want to change.",
        "parameters": [
            {
                "name": "old_text",
                "desc": "The text string in which you want to replace some characters."
            },
            {
                "name": "start_num",
                "desc": "The position of the character in old_text that you want to replace with new_text."
            },
            {
                "name": "num_chars",
                "desc": "The number of characters in old_text that you want REPLACE to replace."
            },
            {
                "name": "new_text",
                "desc": "The text that will replace characters in old_text."
            }
        ]
    },
    {
        "name": "UPPER",
        "category": "Text",
        "syntax": "UPPER(text)",
        "summary": "Converts all letters in a text string to uppercase.",
        "common_errors": [
            "No error, but returns non-alphabetic characters unchanged."
        ],
        "best_practice": "Use UPPER for standardizing text entries, especially for IDs or codes, to ensure consistent formatting.",
        "parameters": [
            {
                "name": "text",
                "desc": "The text you want to convert to uppercase."
            }
        ]
    },
    {
        "name": "LOWER",
        "category": "Text",
        "syntax": "LOWER(text)",
        "summary": "Converts all letters in a text string to lowercase.",
        "common_errors": [
            "No error, but returns non-alphabetic characters unchanged."
        ],
        "best_practice": "Useful for standardizing text for comparisons or data entry, ensuring case-insensitivity.",
        "parameters": [
            {
                "name": "text",
                "desc": "The text you want to convert to lowercase."
            }
        ]
    },
    {
        "name": "PROPER",
        "category": "Text",
        "syntax": "PROPER(text)",
        "summary": "Capitalizes the first letter in each word of a text string and converts all other letters to lowercase.",
        "common_errors": [
            "No error, but might not produce desired results for unusual text patterns (e.g., proper nouns with internal caps)."
        ],
        "best_practice": "Apply PROPER to names or titles to ensure consistent capitalization, improving readability.",
        "parameters": [
            {
                "name": "text",
                "desc": "The text you want to convert to proper case."
            }
        ]
    },
    {
        "name": "VALUE",
        "category": "Text",
        "syntax": "VALUE(text)",
        "summary": "Converts a text string that represents a number to a number.",
        "common_errors": [
            "#VALUE! if the text argument cannot be converted to a numeric value."
        ],
        "best_practice": "Use VALUE when importing data that treats numbers as text to enable arithmetic operations.",
        "parameters": [
            {
                "name": "text",
                "desc": "The text enclosed in quotation marks, a formula that returns a text value, or a reference to a cell containing text."
            }
        ]
    },
    {
        "name": "CLEAN",
        "category": "Text",
        "syntax": "CLEAN(text)",
        "summary": "Removes all non-printable characters from text.",
        "common_errors": [
            "No error, but may not remove all unwanted characters (e.g., spaces, tabs) if they are considered printable."
        ],
        "best_practice": "Run CLEAN on imported data to remove hidden control characters that can cause formatting or calculation issues.",
        "parameters": [
            {
                "name": "text",
                "desc": "Any worksheet information from which you want to remove non-printable characters."
            }
        ]
    },
    {
        "name": "REPT",
        "category": "Text",
        "syntax": "REPT(text, num_times)",
        "summary": "Repeats text a given number of times.",
        "common_errors": [
            "#VALUE! if num_times is non-numeric.",
            "Returning empty string if num_times is 0."
        ],
        "best_practice": "Useful for creating simple bar charts or visual indicators using repeated characters.",
        "parameters": [
            {
                "name": "text",
                "desc": "The text you want to repeat."
            },
            {
                "name": "num_times",
                "desc": "A positive number specifying the number of times to repeat text."
            }
        ]
    },
    {
        "name": "EXACT",
        "category": "Text",
        "syntax": "EXACT(text1, text2)",
        "summary": "Checks if two text values are exactly the same (case-sensitive) and returns TRUE or FALSE.",
        "common_errors": [
            "Returns FALSE due to leading/trailing spaces if not TRIMmed first."
        ],
        "best_practice": "Always TRIM text arguments before using EXACT to ensure that leading/trailing spaces don't cause false negatives.",
        "parameters": [
            {
                "name": "text1",
                "desc": "The first text string."
            },
            {
                "name": "text2",
                "desc": "The second text string."
            }
        ]
    },
    {
        "name": "FIND",
        "category": "Text",
        "syntax": "FIND(find_text, within_text, [start_num])",
        "summary": "Finds one text value within another (case-sensitive) and returns the starting position of find_text.",
        "common_errors": [
            "#VALUE! if find_text is not found in within_text."
        ],
        "best_practice": "Use FIND when you need a case-sensitive search; for case-insensitive, use SEARCH (if not already excluded).",
        "parameters": [
            {
                "name": "find_text",
                "desc": "The text you want to find."
            },
            {
                "name": "within_text",
                "desc": "The text containing the text you want to find."
            },
            {
                "name": "start_num",
                "desc": "Optional. Specifies the character at which to start the search. The first character in within_text is character 1."
            }
        ]
    },
    {
        "name": "MEDIAN",
        "category": "Statistical",
        "syntax": "MEDIAN(number1, [number2], ...)",
        "summary": "Returns the median of the given numbers, which is the number in the middle of a set of numbers.",
        "common_errors": [
            "#NUM! if no numbers are provided."
        ],
        "best_practice": "Use MEDIAN to find the middle value in a dataset, which is less affected by outliers than the AVERAGE.",
        "parameters": [
            {
                "name": "number1",
                "desc": "The first number, range, or array for which you want the median."
            },
            {
                "name": "number2",
                "desc": "Additional numbers, ranges, or arrays."
            }
        ]
    },
    {
        "name": "MODE.SNGL",
        "category": "Statistical",
        "syntax": "MODE.SNGL(number1, [number2], ...)",
        "summary": "Returns the single, most frequently occurring, or repetitive value in an array or range of data.",
        "common_errors": [
            "#N/A if no numbers are provided or if there are no duplicate numbers."
        ],
        "best_practice": "MODE.SNGL is useful for finding the most common item in a list of numerical data.",
        "parameters": [
            {
                "name": "number1",
                "desc": "The first number, range, or array for which you want the mode."
            },
            {
                "name": "number2",
                "desc": "Additional numbers, ranges, or arrays."
            }
        ]
    },
    {
        "name": "STDEV.P",
        "category": "Statistical",
        "syntax": "STDEV.P(number1, [number2], ...)",
        "summary": "Calculates standard deviation based on the entire population, providing a measure of how widely values are dispersed from the average.",
        "common_errors": [
            "#DIV/0! if fewer than two numbers are supplied.",
            "#VALUE! if text values are included in numeric arguments."
        ],
        "best_practice": "Use STDEV.P when your data represents the entire population you are interested in.",
        "parameters": [
            {
                "name": "number1",
                "desc": "The first number, range, or array corresponding to a population."
            },
            {
                "name": "number2",
                "desc": "Additional numbers, ranges, or arrays."
            }
        ]
    },
    {
        "name": "VAR.P",
        "category": "Statistical",
        "syntax": "VAR.P(number1, [number2], ...)",
        "summary": "Calculates variance based on the entire population, which is the average of the squared deviations from the mean.",
        "common_errors": [
            "#DIV/0! if fewer than two numbers are supplied.",
            "#VALUE! if text values are included in numeric arguments."
        ],
        "best_practice": "Use VAR.P when your data represents the entire population to understand data dispersion.",
        "parameters": [
            {
                "name": "number1",
                "desc": "The first number, range, or array corresponding to a population."
            },
            {
                "name": "number2",
                "desc": "Additional numbers, ranges, or arrays."
            }
        ]
    },
    {
        "name": "QUARTILE.INC",
        "category": "Statistical",
        "syntax": "QUARTILE.INC(array, quart)",
        "summary": "Returns the quartile of a data set, based on percentile values from 0 to 1, inclusive.",
        "common_errors": [
            "#VALUE! if array is empty or contains non-numeric values.",
            "#NUM! if quart is not an integer 0, 1, 2, 3, or 4."
        ],
        "best_practice": "Use QUARTILE.INC to divide a dataset into four equal parts to analyze data distribution.",
        "parameters": [
            {
                "name": "array",
                "desc": "The array or range of numeric values for which you want the quartile."
            },
            {
                "name": "quart",
                "desc": "Indicates which quartile value to return (0, 1, 2, 3, or 4)."
            }
        ]
    },
    {
        "name": "PERCENTILE.INC",
        "category": "Statistical",
        "syntax": "PERCENTILE.INC(array, k)",
        "summary": "Returns the k-th percentile of values in a range, where k is in the range 0..1 inclusive.",
        "common_errors": [
            "#VALUE! if array is empty or contains non-numeric values.",
            "#NUM! if k is not between 0 and 1, or if array is empty."
        ],
        "best_practice": "Useful for identifying values at a specific percentile, such as top 10% or bottom 25%.",
        "parameters": [
            {
                "name": "array",
                "desc": "The array or range of data that defines relative standing."
            },
            {
                "name": "k",
                "desc": "The percentile value between 0 and 1, inclusive."
            }
        ]
    },
    {
        "name": "RANK.EQ",
        "category": "Statistical",
        "syntax": "RANK.EQ(number, ref, [order])",
        "summary": "Returns the rank of a number in a list of numbers; its size relative to other values in the list.",
        "common_errors": [
            "#N/A if number is not found in ref.",
            "#VALUE! if order is non-numeric."
        ],
        "best_practice": "When multiple values have the same rank, RANK.EQ assigns the same rank to all of them, showing their shared position.",
        "parameters": [
            {
                "name": "number",
                "desc": "The number whose rank you want to find."
            },
            {
                "name": "ref",
                "desc": "A list of numbers, an array, or a reference to a list of numbers. Non-numeric values are ignored."
            },
            {
                "name": "order",
                "desc": "Optional. 0 (or omitted) for descending rank, any non-zero value for ascending rank."
            }
        ]
    },
    {
        "name": "LARGE",
        "category": "Statistical",
        "syntax": "LARGE(array, k)",
        "summary": "Returns the k-th largest value in a data set.",
        "common_errors": [
            "#NUM! if array is empty or if k is less than or equal to 0 or greater than the number of data points."
        ],
        "best_practice": "Use LARGE to find specific top values, such as the 3rd highest sales figure.",
        "parameters": [
            {
                "name": "array",
                "desc": "The array or range of data for which you want to determine the k-th largest value."
            },
            {
                "name": "k",
                "desc": "The position (from the largest) in the array or data range of the value to return."
            }
        ]
    },
    {
        "name": "SMALL",
        "category": "Statistical",
        "syntax": "SMALL(array, k)",
        "summary": "Returns the k-th smallest value in a data set.",
        "common_errors": [
            "#NUM! if array is empty or if k is less than or equal to 0 or greater than the number of data points."
        ],
        "best_practice": "Use SMALL to find specific bottom values, such as the 2nd lowest test score.",
        "parameters": [
            {
                "name": "array",
                "desc": "The array or range of data for which you want to determine the k-th smallest value."
            },
            {
                "name": "k",
                "desc": "The position (from the smallest) in the array or data range of the value to return."
            }
        ]
    },
    {
        "name": "MIN",
        "category": "Statistical",
        "syntax": "MIN(number1, [number2], ...)",
        "summary": "Returns the smallest number in a set of values.",
        "common_errors": [
            "Returns 0 if a range contains empty cells and is used in contexts expecting numeric input.",
            "Ignores text and logical values if directly entered as arguments."
        ],
        "best_practice": "MIN works efficiently on ranges to quickly identify the lowest value; ensure the range contains only numbers for accurate results.",
        "parameters": [
            {
                "name": "number1",
                "desc": "The first number, range, or array from which you want to find the minimum value."
            },
            {
                "name": "number2",
                "desc": "Additional numbers, ranges, or arrays."
            }
        ]
    },
    {
        "name": "MAX",
        "category": "Statistical",
        "syntax": "MAX(number1, [number2], ...)",
        "summary": "Returns the largest number in a set of values.",
        "common_errors": [
            "Returns 0 if a range contains empty cells and is used in contexts expecting numeric input.",
            "Ignores text and logical values if directly entered as arguments."
        ],
        "best_practice": "MAX works efficiently on ranges to quickly identify the highest value; ensure the range contains only numbers for accurate results.",
        "parameters": [
            {
                "name": "number1",
                "desc": "The first number, range, or array from which you want to find the maximum value."
            },
            {
                "name": "number2",
                "desc": "Additional numbers, ranges, or arrays."
            }
        ]
    },
    {
        "name": "GEOMEAN",
        "category": "Statistical",
        "syntax": "GEOMEAN(number1, [number2], ...)",
        "summary": "Returns the geometric mean of a set of positive data points, useful for finding the average growth rates or returns.",
        "common_errors": [
            "#NUM! if any of the numbers are negative or if there are too few data points.",
            "#VALUE! if text values are included in numeric arguments."
        ],
        "best_practice": "Use GEOMEAN for averaging values that represent rates of change or geometric progressions, such as investment returns.",
        "parameters": [
            {
                "name": "number1",
                "desc": "The first number, range, or array for which you want to calculate the geometric mean."
            },
            {
                "name": "number2",
                "desc": "Additional numbers, ranges, or arrays."
            }
        ]
    },
    {
        "name": "HARMEAN",
        "category": "Statistical",
        "syntax": "HARMEAN(number1, [number2], ...)",
        "summary": "Returns the harmonic mean of a data set, which is the reciprocal of the arithmetic mean of the reciprocals.",
        "common_errors": [
            "#NUM! if any of the data points are less than or equal to zero or if no numbers are provided.",
            "#DIV/0! if any number in the dataset is 0."
        ],
        "best_practice": "Apply HARMEAN for averaging rates or when dealing with values that have a relationship to a unit of time or distance.",
        "parameters": [
            {
                "name": "number1",
                "desc": "The first number, range, or array for which you want to calculate the harmonic mean."
            },
            {
                "name": "number2",
                "desc": "Additional numbers, ranges, or arrays."
            }
        ]
    },
    {
        "name": "SKEW",
        "category": "Statistical",
        "syntax": "SKEW(number1, [number2], ...)",
        "summary": "Returns the skewness of a distribution, indicating the degree of asymmetry of a distribution around its mean.",
        "common_errors": [
            "#DIV/0! if fewer than three data points are provided or standard deviation is zero.",
            "#VALUE! if text values are included in numeric arguments."
        ],
        "best_practice": "Use SKEW to understand the shape of your data distribution and identify potential biases or extreme values.",
        "parameters": [
            {
                "name": "number1",
                "desc": "The first number, range, or array of data points."
            },
            {
                "name": "number2",
                "desc": "Additional numbers, ranges, or arrays of data points."
            }
        ]
    },
    {
        "name": "KURT",
        "category": "Statistical",
        "syntax": "KURT(number1, [number2], ...)",
        "summary": "Returns the kurtosis of a data set, a measure of the 'peakedness' or 'flatness' of a distribution relative to a normal distribution.",
        "common_errors": [
            "#DIV/0! if fewer than four data points are provided.",
            "#VALUE! if text values are included in numeric arguments."
        ],
        "best_practice": "Use KURT to assess the fatness of the tails of your data distribution, which is important in risk analysis.",
        "parameters": [
            {
                "name": "number1",
                "desc": "The first number, range, or array of data points."
            },
            {
                "name": "number2",
                "desc": "Additional numbers, ranges, or arrays of data points."
            }
        ]
    },
    {
        "name": "FORECAST.ETS",
        "category": "Statistical",
        "syntax": "FORECAST.ETS(target_date, values, timeline, [seasonality], [data_completion], [aggregation])",
        "summary": "Predicts a future value based on existing historical values by using the AAA version of the Exponential Smoothing (ETS) algorithm.",
        "common_errors": [
            "#N/A if target_date is not sorted or does not follow a consistent step.",
            "#VALUE! if any argument is non-numeric or of incorrect type."
        ],
        "best_practice": "Ensure your 'timeline' argument is sorted and has a consistent step between data points for accurate forecasting.",
        "parameters": [
            {
                "name": "target_date",
                "desc": "The data point for which you want to predict a value."
            },
            {
                "name": "values",
                "desc": "The historical values for which you want to forecast the next points."
            },
            {
                "name": "timeline",
                "desc": "The independent array or range of numeric data with a consistent step between them."
            },
            {
                "name": "seasonality",
                "desc": "Optional. The length of the seasonal pattern. 0 for no seasonality, 1 for automatic detection, or a custom number."
            },
            {
                "name": "data_completion",
                "desc": "Optional. How to handle missing data. 0 for zeros, 1 for averaging adjacent points (default)."
            },
            {
                "name": "aggregation",
                "desc": "Optional. How to aggregate multiple values with the same timestamp. 0 for AVERAGE (default), 1 for SUM, etc."
            }
        ]
    },
    {
        "name": "ROUND",
        "category": "Math & Trig",
        "syntax": "=ROUND(number, num_digits)",
        "summary": "Rounds a number to a specified number of digits.",
        "common_errors": [
            "Rounding issues in financial calculations",
            "Confusing with formatting (which only changes display)"
        ],
        "best_practice": "Use ROUND to prevent floating-point errors from compounding in large financial models.",
        "parameters": [
            {
                "name": "number",
                "desc": "The number you want to round."
            },
            {
                "name": "num_digits",
                "desc": "The number of digits to which you want to round the number."
            }
        ]
    },
    {
        "name": "ROUNDUP",
        "category": "Math & Trig",
        "syntax": "=ROUNDUP(number, num_digits)",
        "summary": "Rounds a number up, away from zero.",
        "common_errors": [
            "Treating negative numbers identically to positive numbers (rounds away from 0)"
        ],
        "best_practice": "Useful for calculating required materials (e.g., you need to buy whole cans of paint).",
        "parameters": [
            {
                "name": "number",
                "desc": "The number to round up."
            },
            {
                "name": "num_digits",
                "desc": "Number of digits."
            }
        ]
    },
    {
        "name": "ROUNDDOWN",
        "category": "Math & Trig",
        "syntax": "=ROUNDDOWN(number, num_digits)",
        "summary": "Rounds a number down, toward zero.",
        "common_errors": [
            "Confusing with INT or TRUNC"
        ],
        "best_practice": "Use when you want to disregard fractional parts below a certain significance reliably.",
        "parameters": [
            {
                "name": "number",
                "desc": "The number to round down."
            },
            {
                "name": "num_digits",
                "desc": "Number of digits."
            }
        ]
    },
    {
        "name": "OFFSET",
        "category": "Lookup & Reference",
        "syntax": "=OFFSET(reference, rows, cols, [height], [width])",
        "summary": "Returns a reference to a range that is a specified number of rows and columns from a cell or range of cells.",
        "common_errors": [
            "#REF! if the offset goes off the sheet edge",
            "Volatile function causing slow recalculation"
        ],
        "best_practice": "Use INDEX instead if possible, as OFFSET is volatile and can slow down large workbooks.",
        "parameters": [
            {
                "name": "reference",
                "desc": "Starting point."
            },
            {
                "name": "rows",
                "desc": "Rows to move down/up."
            },
            {
                "name": "cols",
                "desc": "Cols to move right/left."
            },
            {
                "name": "[height]",
                "desc": "Height of the returned range."
            },
            {
                "name": "[width]",
                "desc": "Width of returned range."
            }
        ]
    },
    {
        "name": "INDIRECT",
        "category": "Lookup & Reference",
        "syntax": "=INDIRECT(ref_text, [a1])",
        "summary": "Returns the reference specified by a text string. Evaluates text as a cell reference.",
        "common_errors": [
            "#REF! when referring to another workbook that is closed",
            "Volatile function causing slow recalculations"
        ],
        "best_practice": "Very useful for creating dynamic dropdown lists (dependent data validation), but use sparingly.",
        "parameters": [
            {
                "name": "ref_text",
                "desc": "A text string specifying a reference."
            },
            {
                "name": "[a1]",
                "desc": "TRUE for A1 style, FALSE for R1C1 style."
            }
        ]
    },
    {
        "name": "ISBLANK",
        "category": "Information",
        "syntax": "=ISBLANK(value)",
        "summary": "Checks whether a reference is to an empty cell, and returns TRUE or FALSE.",
        "common_errors": [
            "Returns FALSE if a cell contains a formula that returns an empty string (\"\")"
        ],
        "best_practice": "For cells with formulas returning \"\", test with LEN(A1)=0 instead of ISBLANK.",
        "parameters": [
            {
                "name": "value",
                "desc": "The value you want tested (usually a cell reference)."
            }
        ]
    },
    {
        "name": "ISNUMBER",
        "category": "Information",
        "syntax": "=ISNUMBER(value)",
        "summary": "Checks whether a value is a number, and returns TRUE or FALSE.",
        "common_errors": [
            "Returns FALSE for numbers formatted/stored as text"
        ],
        "best_practice": "Combine with SEARCH to check if a string contains another string (e.g., =ISNUMBER(SEARCH(\"apple\", A1))).",
        "parameters": [
            {
                "name": "value",
                "desc": "The value you want tested."
            }
        ]
    },
    {
        "name": "ISERROR",
        "category": "Information",
        "syntax": "=ISERROR(value)",
        "summary": "Checks whether a value is an error (#N/A, #VALUE!, #REF!, #DIV/0!, #NUM!, #NAME?, or #NULL!), and returns TRUE or FALSE.",
        "common_errors": [
            "Hiding legitimate errors that need to be addressed"
        ],
        "best_practice": "For newer Excel versions, prefer IFERROR directly instead of IF(ISERROR(...)).",
        "parameters": [
            {
                "name": "value",
                "desc": "The value you want tested."
            }
        ]
    },
    {
        "name": "CEILING",
        "category": "Math & Trig",
        "syntax": "=CEILING(number, significance)",
        "summary": "Rounds a number up to the nearest multiple of significance.",
        "common_errors": [
            "#NUM! if number and significance have different signs"
        ],
        "best_practice": "Great for pricing items (e.g., rounding up prices to the nearest $0.99) or calculating items bought in packs.",
        "parameters": [
            {
                "name": "number",
                "desc": "The value you want to round."
            },
            {
                "name": "significance",
                "desc": "The multiple to which you want to round."
            }
        ]
    },
    {
        "name": "FLOOR",
        "category": "Math & Trig",
        "syntax": "=FLOOR(number, significance)",
        "summary": "Rounds a number down to the nearest multiple of significance.",
        "common_errors": [
            "#NUM! if number and significance have different signs"
        ],
        "best_practice": "Use FLOOR.MATH in newer Excel versions for better handling of negative numbers.",
        "parameters": [
            {
                "name": "number",
                "desc": "The numeric value you want to round."
            },
            {
                "name": "significance",
                "desc": "The multiple to which you want to round."
            }
        ]
    },
    {
        "name": "RANDBETWEEN",
        "category": "Math & Trig",
        "syntax": "=RANDBETWEEN(bottom, top)",
        "summary": "Returns a random integer number between the numbers you specify.",
        "common_errors": [
            "Volatile function that recalcs on every worksheet change, slowing down the sheet if used extensively"
        ],
        "best_practice": "Copy and Paste Special > Values to lock in the random numbers after generating them.",
        "parameters": [
            {
                "name": "bottom",
                "desc": "The smallest integer RANDBETWEEN will return."
            },
            {
                "name": "top",
                "desc": "The largest integer RANDBETWEEN will return."
            }
        ]
    },
    {
        "name": "PMT",
        "category": "Financial",
        "syntax": "=PMT(rate, nper, pv, [fv], [type])",
        "summary": "Calculates the payment for a loan based on constant payments and a constant interest rate.",
        "common_errors": [
            "Using annual rate for monthly payments. Remember to divide rate by 12 and multiply terms by 12"
        ],
        "best_practice": "Ensure the units for rate and nper are consistent. Present value (the loan amount) should typically be positive, making the result negative (cash outflow).",
        "parameters": [
            {
                "name": "rate",
                "desc": "The interest rate for the loan."
            },
            {
                "name": "nper",
                "desc": "The total number of payments."
            },
            {
                "name": "pv",
                "desc": "The present value (principal)."
            },
            {
                "name": "[fv]",
                "desc": "Future value (default 0)."
            },
            {
                "name": "[type]",
                "desc": "0 (end of period) or 1 (beginning). "
            }
        ]
    },
    {
        "name": "FV",
        "category": "Financial",
        "syntax": "=FV(rate, nper, pmt, [pv], [type])",
        "summary": "Returns the future value of an investment based on periodic, constant payments and a constant interest rate.",
        "common_errors": [
            "Not using consistent time units for rate and nper"
        ],
        "best_practice": "Cash outflows (like deposits to savings) must be represented as negative numbers, and cash inflows as positive numbers.",
        "parameters": [
            {
                "name": "rate",
                "desc": "Interest rate per period."
            },
            {
                "name": "nper",
                "desc": "Total number of payment periods."
            },
            {
                "name": "pmt",
                "desc": "Payment made each period."
            },
            {
                "name": "[pv]",
                "desc": "Present value."
            },
            {
                "name": "[type]",
                "desc": "0 or 1."
            }
        ]
    },
    {
        "name": "TRANSPOSE",
        "category": "Lookup & Reference",
        "syntax": "=TRANSPOSE(array)",
        "summary": "Returns a vertical range of cells as a horizontal range, or vice versa.",
        "common_errors": [
            "Legacy Excel requires pressing Ctrl+Shift+Enter, otherwise you get a #VALUE! error"
        ],
        "best_practice": "In modern Excel (365/2021), it spills automatically. Useful for flipping tables without manual copy/paste special.",
        "parameters": [
            {
                "name": "array",
                "desc": "An array or range of cells on a worksheet that you want to transpose."
            }
        ]
    },
    {
        "name": "CHOOSE",
        "category": "Lookup & Reference",
        "syntax": "=CHOOSE(index_num, value1, [value2], ...)",
        "summary": "Chooses a value or action to perform from a list of values, based on an index number.",
        "common_errors": [
            "#VALUE! if index_num is less than 1 or greater than the number of values in the list"
        ],
        "best_practice": "Great for quickly assigning categories (e.g., =CHOOSE(A1, \"Low\", \"Medium\", \"High\")). Often paired with random number generation like RANDBETWEEN.",
        "parameters": [
            {
                "name": "index_num",
                "desc": "Specifies which value argument is selected (must be between 1 and 254)."
            },
            {
                "name": "value1",
                "desc": "1st value from which to choose."
            },
            {
                "name": "[value2]",
                "desc": "2nd value, up to 254."
            }
        ]
    },
    {
        "name": "INDEX + MATCH",
        "category": "Combo Recipe",
        "syntax": "=INDEX(return_range, MATCH(lookup_value, lookup_range, 0))",
        "summary": "The ultimate two-way lookup combo that overcomes VLOOKUP's left-to-right limitation.",
        "common_errors": [
            "#N/A if no match is found",
            "#REF! if ranges are different sizes"
        ],
        "best_practice": "Lock your ranges with $ (absolute references) before dragging the formula down.",
        "parameters": [
            {
                "name": "return_range",
                "desc": "The column containing the answer you want."
            },
            {
                "name": "lookup_value",
                "desc": "The value you are searching for."
            },
            {
                "name": "lookup_range",
                "desc": "The column to search in."
            }
        ]
    },
    {
        "name": "VLOOKUP + IFERROR",
        "category": "Combo Recipe",
        "syntax": "=IFERROR(VLOOKUP(...), \"Not Found\")",
        "summary": "Cleans up ugly #N/A errors when VLOOKUP fails to find a match.",
        "common_errors": [
            "Returning \"\" (blank) which might cause math errors later down the line if used in calculations."
        ],
        "best_practice": "Use descriptive error messages like \"Pending\" or \"Review\" instead of generic blanks.",
        "parameters": [
            {
                "name": "value_if_error",
                "desc": "What to display instead of the #N/A error."
            }
        ]
    },
    {
        "name": "IF + AND + OR",
        "category": "Combo Recipe",
        "syntax": "=IF(AND(condition1, OR(condition2, condition3)), true_result, false_result)",
        "summary": "Builds complex logical tests requiring multiple conditions to be met simultaneously.",
        "common_errors": [
            "Nesting limits (too many parenthesis)",
            "Logical overlap resulting in unexpected TRUE/FALSE."
        ],
        "best_practice": "Map out your logic on paper before writing nested IF/AND/OR statements.",
        "parameters": [
            {
                "name": "logical_test",
                "desc": "The combination of AND/OR logic to evaluate."
            }
        ]
    },
    {
        "name": "SUMIFS + EOMONTH",
        "category": "Combo Recipe",
        "syntax": "=SUMIFS(sum_range, date_range, \">=\"&start_date, date_range, \"<=\"&EOMONTH(start_date, 0))",
        "summary": "Dynamically sums data for an entire accounting month based on a single input date.",
        "common_errors": [
            "Forgetting the \"&\" concatenation operator when combining criteria and formulas."
        ],
        "best_practice": "Use named ranges for dates to make this formula much easier to read.",
        "parameters": [
            {
                "name": "start_date",
                "desc": "The beginning of the month you want to sum."
            }
        ]
    },
    {
        "name": "INDEX + MATCH + MATCH",
        "category": "Combo Recipe",
        "syntax": "=INDEX(range, MATCH(row_value, row_range, 0), MATCH(col_value, col_range, 0))",
        "summary": "Performs a 2D matrix lookup (finding a value at the intersection of a specific row and column).",
        "common_errors": [
            "Getting the row and column MATCH statements backwards.",
            "Ranges not aligning with the main INDEX matrix."
        ],
        "best_practice": "Ensure your INDEX range exactly encompasses only the data, while MATCH ranges cover the exact dimension headers.",
        "parameters": [
            {
                "name": "row_value",
                "desc": "The lookup value for the vertical axis."
            },
            {
                "name": "col_value",
                "desc": "The lookup value for the horizontal axis."
            }
        ]
    },
    {
        "name": "FILTER + SORT",
        "category": "Combo Recipe",
        "syntax": "=SORT(FILTER(array, include), sort_index, sort_order)",
        "summary": "Extracts matching data and immediately orders it alphabetically or numerically in one fluid step.",
        "common_errors": [
            "#CALC! if the FILTER finds nothing and no [if_empty] argument is provided."
        ],
        "best_practice": "Always provide the [if_empty] argument in FILTER to prevent the #CALC! error from breaking the SORT.",
        "parameters": [
            {
                "name": "include",
                "desc": "The boolean array logic determining what to filter."
            },
            {
                "name": "sort_index",
                "desc": "Which column number in the filtered array to sort by."
            }
        ]
    },
    {
        "name": "UNIQUE + SORT",
        "category": "Combo Recipe",
        "syntax": "=SORT(UNIQUE(array))",
        "summary": "Creates a clean, alphabetized list of distinct values from a messy column of duplicates.",
        "common_errors": [
            "Spill errors (#SPILL!) if there is data blocking the output range."
        ],
        "best_practice": "Use this on a separate 'Admin' or 'Lists' tab to feed clean data into Data Validation dropdowns.",
        "parameters": [
            {
                "name": "array",
                "desc": "The range containing raw data with duplicates."
            }
        ]
    },
    {
        "name": "XLOOKUP + XLOOKUP",
        "category": "Combo Recipe",
        "syntax": "=XLOOKUP(val1, range1, XLOOKUP(val2, range2, return_matrix))",
        "summary": "A modern, robust alternative to INDEX+MATCH+MATCH for two-way matrix lookups.",
        "common_errors": [
            "Selecting misaligned return matrices compared to the lookup arrays."
        ],
        "best_practice": "This is often easier to read than INDEX/MATCH/MATCH, but ensure you understand which XLOOKUP returns the array.",
        "parameters": [
            {
                "name": "val1",
                "desc": "The row lookup value."
            },
            {
                "name": "val2",
                "desc": "The column lookup value."
            }
        ]
    },
    {
        "name": "COUNTIFS + TODAY",
        "category": "Combo Recipe",
        "syntax": "=COUNTIFS(date_range, \"<=\"&TODAY(), status_range, \"Pending\")",
        "summary": "Creates dynamic aging reports, automatically counting overdue items relative to the current date.",
        "common_errors": [
            "Hardcoding dates instead of using TODAY(), making the sheet static."
        ],
        "best_practice": "Since TODAY() is volatile and recalculates constantly, avoid using it in tens of thousands of rows if performance drops.",
        "parameters": [
            {
                "name": "date_range",
                "desc": "The range containing due dates."
            }
        ]
    },
    {
        "name": "VLOOKUP + MATCH",
        "category": "Combo Recipe",
        "syntax": "=VLOOKUP(lookup_value, table_array, MATCH(column_header, header_range, 0), FALSE)",
        "summary": "Makes VLOOKUP totally dynamic so it doesn't break when you insert or delete columns in your data table.",
        "common_errors": [
            "Forgetting to lock the header_range ($) inside the MATCH function.",
            "Header_range not starting at the same column as table_array."
        ],
        "best_practice": "This is the best way to future-proof legacy VLOOKUPs before migrating to XLOOKUP.",
        "parameters": [
            {
                "name": "column_header",
                "desc": "The name of the column you want to return data from."
            }
        ]
    }
]